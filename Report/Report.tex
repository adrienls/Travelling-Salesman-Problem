\documentclass[a4paper, 12pt]{report}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage[boxed, lined, linesnumbered]{algorithm2e}


\title{Final project - Travelling Salesman Problem}
\author{Fanoarii \textsc{Boyer} - Jérémy \textsc{Beaugeard} - Arthur \textsc{Guerineau} - Adrien \textsc{Le Saux} \\*[20pt] CIR3 - Graph Theory - Leandro \textsc{Montero}}
\date{30 April 2020}

\begin{document}
	\begin{titlepage}
		\begin{figure}
			\begin{center}
				\includegraphics[width=150pt]{isen.png}
				\maketitle
			\end{center}
		\end{figure}
	\end{titlepage}

	\tableofcontents
	
	\chapter{Introduction}
	\BlankLine
	In this final graph theory project, we try to solve the Travelling Salesman Problem (TSP) using different algorithms and heuristics.
	Before we get to the code, it is important to consider how we are going to model the graphs.
	\BlankLine
	In the TSP, we work with undirected complete graphs, which means they are very dense. Adjacency lists are useful for sparse graphs, but in our case it will be more appropriate, in terms of complexity, to use adjacency matrix.
	\BlankLine
	To implement the adjacency matrix we will use the C++ Boost library. In this project we seek to compare the performance between different solutions to the same problem. As C++ is a low-level programming language it is very fast and will be suitable for our use. Moreover, the boost library is very well known and widely documented.
	
	\chapter{Real-life situations}
	
	\chapter{Exact algorithm}
		\section{Pseudo-code}
			\begin{algorithm}
				\DontPrintSemicolon
				\KwIn{$G$ is an undirected complete weighted graph with $n$ vertices}
				\KwOut{The optimal path found and the corresponding distance}
				\BlankLine
				$finalPath \leftarrow empty$\;
				$finalDistance \leftarrow \infty$\;
				\BlankLine
					$path \leftarrow$ each vertex number from $1$ to $n$\;
					$distance \leftarrow 0$\;
					\BlankLine
					\ForEach{permutation $P$ of $path$}{
						$distance \leftarrow$ total distance of the path\;
						\If{$distance$ < $finalDistance$}{
							$finalDistance \leftarrow distance$\;
							$finalPath \leftarrow P$\;
						}
					}
				\BlankLine
				\Return $finalPath$ and $finalDistance$\;
			\end{algorithm}
		
		\section{Time complexity}
		There are $n!$ permutations for a path of size $n$. Therefore we are going to execute the $ForEach$ loop $n!$ times.
		Moreover, we need to add the weight between each vertex of the path to find the total distance, so we need to do $n$. As this calculation is inside the $ForEach$ loop we obtain an overall complexity of:
		\begin{center}
			$O(n*n!)$
		\end{center}
		This is a brute-force algorithm, which tries out the exhaustive list of possible solutions. It is the most intuitive way to find an exact solution. However using the Held–Karp algorithm or a branch-and-cut algorithm could greatly improve the complexity. Those algorithms are much more advanced and use knowledge linked to dynamic and linear programming. There were therefore too complex to implement in this project.
		\section{Optimal Solution}
		\section{Execution time and performance}
	
	\chapter{Constructive heuristic}

		\section{Pseudo-code}
			\begin{algorithm}
				\DontPrintSemicolon
				\KwIn{$G$ is an undirected complete weighted graph with $n$ vertices}
				\KwOut{The optimal path found and the corresponding distance}
				\BlankLine
				$path \leftarrow empty$\;
				$distance \leftarrow 0$\;
				$firstVertex \leftarrow$ choose randomly a vertex in the graph\;
				$currentVertex \leftarrow firstVertex$\;
				Mark $currentVertex$ as discovered\;
				\BlankLine
				\While{there are still undiscovered vertices}{
					$minimumWeigth \leftarrow \infty$\;
					\BlankLine
					\ForEach{adjacent vertex $V$ not discovered}{
						$w \leftarrow$ weight between $currentVertex$ and $V$\;
						\If{$w$ < $minimumWeight$}{
							$minimumWeight \leftarrow w$\;
							$nextVertex \leftarrow V$\;
						}
					}
					\BlankLine
					$path \leftarrow path$ + $nextVertex$\;
					$currentVertex \leftarrow nextVertex$\;
					$distance \leftarrow distance $ + $minimumWeight$\;
				}
				\BlankLine
				$lastWeight \leftarrow$ weight from $currentVertex$ to $firstVertex$\;
				$distance \leftarrow distance$ + $lastWeight$\;
			\BlankLine
			\Return $path$ and $distance$\;
			\end{algorithm}

		\section{Time complexity}
			The first loop makes sure that each vertex of the graph has been discovered, it is executed $ n $ times.
			The second loop tests each undiscovered adjacent vertex, thus there are never more than $n-1$ iterations of this loop and its number decreases as the algorithm reaches the end.
			Since the three loops are nested and each of them is $n$ iterations or less, we have an overall complexity of:
			\begin{center}
				O($n^{2}$)
			\end{center}
			We could improve the precision of the solution by running the algorithm $n$ times and starting at each vertex of the graph. By doing this we could keep only the best result but the complexity would become O($n^{3}$). It slightly improve the precision of the solution but greatly decreases the algorithm performance.
		\section{Optimal Solution}
		This algorithm is an implementation of the Nearest neighbour algorithm;
		\section{Execution time and performance}
	
	\chapter{Local search heuristic}
		\section{Pseudo-code}
			\begin{algorithm}
				
			\end{algorithm}
		
		\section{Time complexity}
		\section{Optimal Solution}
		\section{Execution time and performance}
	
	\chapter{GRASP meta-heuristic}
		\section{Pseudo-code}
			\begin{algorithm}
				
			\end{algorithm}
		\section{Time complexity}
		\section{Optimal Solution}
		\section{Execution time and performance}
	
	\chapter{Conclusion}
	
	%\bibliographystyle{unsrt}
	%\bibliography{Bibliography}
	
\end{document}
