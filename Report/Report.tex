\documentclass[a4paper, 12pt]{report}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage[boxed, lined, linesnumbered]{algorithm2e}


\title{Final project - Travelling Salesman Problem}
\author{Fanoarii \textsc{Boyer} - Jérémy \textsc{Beaugeard} - Arthur \textsc{Guerineau} - Adrien \textsc{Le Saux} \\*[20pt] CIR3 - Graph Theory - Leandro \textsc{Montero}}
\date{30 April 2020}

\begin{document}
	\begin{titlepage}
		\begin{figure}
			\begin{center}
				\includegraphics[width=150pt]{isen.png}
				\maketitle
			\end{center}
		\end{figure}
	\end{titlepage}

	\tableofcontents
	
	\chapter{Introduction}
	\paragraph{}
	In this final graph theory project, we try to solve the Travelling Salesman Problem (TSP) using different algorithms and heuristics.
	Before we get to the code, it is important to consider how we are going to model the graphs.
	\paragraph{}
	In the TSP, we work with undirected complete graphs, which means they are very dense. Adjacency lists are useful for sparse graphs, but in our case it will be more appropriate, in terms of complexity, to use adjacency matrix\cite{complexity}.
	\paragraph{}
	To implement the adjacency matrix\cite{adjacency_matrix} we will use the C++ Boost\cite{boost} library. In this project we seek to compare the performance between different solutions to the same problem. As C++ is a low-level programming language it is very fast and will be suitable for our use. Moreover, the boost library is very well known and widely documented.
	
	\chapter{Real-life situations}
	
	\chapter{Exact algorithm}
		\section{Pseudo-code}
			\begin{algorithm}
				
			\end{algorithm}
		
		\section{Time complexity}
		\section{Optimal Solution}
		\section{Execution time and performance}
	
	\chapter{Constructive heuristic}
		\section{Pseudo-code}
			\begin{algorithm}
				\DontPrintSemicolon
				\KwIn{$G$ is an undirected complete weighted graph with $n$ vertices}
				\KwOut{The optimal path found and the corresponding distance}
				\BlankLine
				$finalPath \leftarrow empty$\;
				$finalDistance \leftarrow \infty$\;
				\BlankLine
				\ForEach{vertex $V$ of $G$}{
					$path \leftarrow empty$\;
					$distance \leftarrow 0$\;
					$currentVertex \leftarrow V$\;
					\BlankLine
					\While{there are still undiscovered vertices}{
						$minimumWeigth \leftarrow \infty$\;
						\BlankLine
						\ForEach{adjacent vertex $V'$ not discovered}{
							$w \leftarrow$ weight between $V$ and $V'$\;
							\If{$w$ < $minimumWeight$}{
								$minimumWeight \leftarrow w$\;
								$currentVertex \leftarrow V'$\;
							}
						}
						\BlankLine
						$path \leftarrow path$ + $currentVertex$\;
						Mark $currentVertex$ as discovered\;
						$distance \leftarrow distance $ + $minimumWeight$\;
					}
					\BlankLine
					$returnToStart \leftarrow$ weight from $nextVertex$ to $V$\;
					$distance \leftarrow distance$ + $returnToStart$\;
					\If{$distance$ < $finalDistance$}{
						$finalDistance \leftarrow distance$\;
						$finalPath \leftarrow path$\;
					}
				}
				\BlankLine
				\Return $finalPath$ and $finalDistance$\;
			\end{algorithm}
	
		\section{Time complexity}
		\section{Optimal Solution}
		\section{Execution time and performance}
	
	\chapter{Local search heuristic}
		\section{Pseudo-code}
			\begin{algorithm}
				
			\end{algorithm}
		
		\section{Time complexity}
		\section{Optimal Solution}
		\section{Execution time and performance}
	
	\chapter{GRASP meta-heuristic}
		\section{Pseudo-code}
			\begin{algorithm}
				
			\end{algorithm}
		\section{Time complexity}
		\section{Optimal Solution}
		\section{Execution time and performance}
	
	\chapter{Conclusion}
	
	\bibliographystyle{unsrt}
	\bibliography{Bibliography}
	
\end{document}
